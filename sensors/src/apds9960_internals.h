/* APDS-9960 register addresses */
#define APDS9960_I2C_ADDRESS    0x39

#define  ENABLE    0x80             /**Enable register*/
/**The read-only ID Register provides the device identification.-> 0xAB*/
#define  ID        0x92           

/** Proximity registers */
/**The Proximity Interrupt Threshold Registers set the high and low trigger points for the comparison function which generates an interrupt. If PDATA, the value generated by proximity channel, crosses below the lower threshold specified, or above the higher threshold, an interrupt may be signaled to the host processor. Interrupt generation is subject to the value set in persistence (PERS).*/
#define  PILT           0x89
#define  PIHT           0x8B
/**The Interrupt Persistence Register sets a value which is compared with the accumulated amount of ALS or Proximity cycles in which results were outside threshold values. Any Proximity or ALS result that is inside threshold values resets the count.
Separate counters are provided for proximity and ALS persistence detection.
PPERS   7:4   Proximity Interrupt Persistence. Controls rate of proximity interrupt to the host processor. 
APERS   3:0   ALS Interrupt Persistence. Controls rate of Clear channel interrupt to the host processor.*/
#define  PERS           0x8C   
/**The CONFIG1 register sets the wait long time. The register is set to 0x40 at power up.
  Bit 6 is reserved, and is automatically set to 1 at POR.
  Bit 5 is reserved, and is automatically set to 1 at POR. If this bit is not set, power consumption will increase during wait states.
  Bit 1 (WLONG) Wait Long. When asserted, the wait cycle is increased by a factor 12x from that programmed in the WTIME register.
*/
#define  CONFIG1        0x8D   
/**The Proximity Pulse Count Register sets Pulse Width Modified current during a Proximity Pulse. The proximity pulse count register bits set the number of pulses to be output on the LDR pin. The Proximity Length register bits set the amount of time the LDR pin is sinking current during a proximity pulse.
PPLEN   <7:6> Proximity Pulse Length. Sets the LED-ON pulse width during a proximity LDR pulse.
_________________________________
|FIELD VALUE  |  PULSE LENGTH   |
|    0        |   4 µs          |
|    1        |   8 µs (default)|
|    2        |   16 µs         |
|    3        |   32 µs         |
|_____________|_________________|

PPULSE <5:0> Proximity Pulse Count. Specifies the number of proximity pulses to be generated on LDR.
Number of pulses is set by PPULSE value plus 1.

_________________________________
|FIELD VALUE  | NUMBER OF PULSES|
|    0        |   1             |
|    1        |   2             |
|    2        |   3             |
|   ..        |                 |
|____63_______|___64____________|
The time described by PPLEN is the actual signal integration time. The LED will be activated slightly longer (typically 1.36 μs) than the integration time. The Proximity Pulse Count Register resets to 0x40*/
#define  PPULSE         0x8E

/** Control Register
Field   Bits  Description
LDRIVE  7:6     LED Drive Strength.
                FIELD VALUELED    CURRENT
                    0               100 mA
                    1                50 mA
                    2                25 mA
                    3              12.5 mA

Reserved 5       Reserved. Write as 0.
Reserved 4       Reserved. Write as 0.
PGAIN   3:2     Proximity Gain Control.
                FIELD VALUE     GAIN VALUE
                    0               1X
                    1               2X
                    2               4X
                    3               8x
AGAIN   1:0
                FIELD VALUE     GAIN VALUE
                    0               1X
                    1               4X
                    2               16X
                    3               64X
*/
#define  CONTROL        0x8F
/**The Configuration Register Two independently enables or disables the saturation interrupts for Proximity and Clear channel. Saturation Interrupts are cleared by accessing the Clear Interrupt registers at 0xE5, 0xE6 and 0xE7. The LED_BOOST bits allow the LDR pin to sink more current above the maximum setting by LDRIVE and GLDRIVE.*/
#define  CONFIG2        0x90
/**The read-only Status Register provides the status of the device. The register is set to 0x04 at power-up.
CPSAT <7> Clear Photodiode Saturation. When asserted, the analog sensor was at the upper end of its
dynamic range. The bit can be de-asserted by sending a Clear channel interrupt command
(0xE6 CICLEAR) or by disabling the ADC (AEN=0). This bit triggers an interrupt if CPSIEN is set.
PGSAT <6> Indicates that an analog saturation event occurred during a previous proximity or gesture
cycle. Once set, this bit remains set until cleared by clear proximity interrupt special function
command (0xE5 PICLEAR) or by disabling Prox (PEN=0). This bit triggers an interrupt if PSIEN
is set.
PINT <5> Proximity Interrupt. This bit triggers an interrupt if PIEN in ENABLE is set.
AINT <4> ALS Interrupt. This bit triggers an interrupt if AIEN in ENABLE is set.
RESERVED <3> Do not care.
GINT <2> Gesture Interrupt. GINT is asserted when GFVLV becomes greater than GFIFOTH or if GVALID
has become asserted when GMODE transitioned to zero. The bit is reset when FIFO is
completely emptied (read).
PVALID <1> Proximity Valid. Indicates that a proximity cycle has completed since PEN was asserted or since PDATA was last read. A read of PDATA automatically clears PVALID.
AVALID <0> ALS Valid. Indicates that an ALS cycle has completed since AEN was asserted or since a read
from any of the ALS/Color data registers. 
*/
#define  STATUS         0x93
/**Proximity data*/
#define  PDATA          0x9C
/**In proximity mode, the UP and RIGHT photodiodes are connected forming a diode pair. The POFFSET_UR is an 8-bit value used to scale an internal offset correction factor to compensate for crosstalk in the application. This value is encoded in sign/magnitude format.*/
#define  POFFSET_UR     0x9D
/**In Proximity mode, the DOWN and LEFT photodiodes are connected forming a diode pair. The POFFSET_DL is an 8-bit value used to scale an internal offset correction factor to compensate for crosstalk in the application. This value is encoded in sign/magnitude format.*/
#define  POFFSET_DL     0x9E
/**The CONFIG3 register is used to select which photodiodes are used for proximity. Two photodiodes are paired to provide signal. In proximity mode, UP and RIGHT photodiodes are connected forming a diode pair; similarly the DOWN and LEFT photodiodes form a diode pair.*/
#define  CONFIG3        0x9F



/**Color registers*/

/**The ATIME register controls the internal integration time of ALS/Color analog to digital converters. Upon power up, the ADC integration time register is set to 0xFF.*/
#define  ATIME          0x82
/** The WTIME controls the amount of time in a low power mode between Proximity and/or ALS cycles. It is set 2.78ms increments unless the WLONG bit is asserted in which case the wait times are 12× longer. WTIME is programmed as a 2’s complement number. Upon power up, the wait time register is set to 0xFF.
 FIELD VALUE                 WAIT TIME       TIME (WLONG = 0)        TIME (WLONG = 1)
   0                            256             712 ms                      8.54 s
   = 256 – TIME / 2.78 ms       …               …
   171                          85              236 ms                      2.84 s
   255                          1               2.78 ms                     0.03 s 

 The wait time register should be configured before AEN and/or PEN is asserted.  
*/
#define  WTIME          0x83
/**ALS level detection uses data generated by the Clear Channel. The ALS Interrupt Threshold registers provide 16-bit values to be used as the high and low thresholds for comparison to the 16-bit CDATA values. If AIEN is enabled and CDATA is greater than AILTH/AIHTH or less than AILTL/AIHTL for the number of consecutive samples specified in APERS an interrupt is asserted on the interrupt pin.*/
#define  AILTL          0x84
#define  AILTH          0x85
#define  AIHTL          0x86
#define  AIHTH          0x87
#define  AGAIN          0x8F //<1:0>

/**Red, green, blue, and clear data is stored as 16-bit values. 
The read sequence must read byte pairs (low followed by high) starting on an even address boundary (0x94, 0x96, 0x98, or 0x9A) inside the RGBC Data Register block. When the lower byte register is read, the upper eight bits are stored into a shadow register, which is read by a subsequent read to the upper byte. The upper register will read the correct value even if additional ADC integration cycles end between the reading of the lower and upper registers.
When reading register contents, a read of the lower byte data automatically latches the corresponding higher byte data (16 bit latch). This feature guarantees that the high byte value has not been updated by the ADC between I2C reads. In addition, reading CDATAL register not only latches CDATAH but also latches all eight RGBC register simultaneously (64 bit latch).*/
#define  CDATAL         0x94
#define  CDATAH         0x95
#define  RDATAL         0x96
#define  RDATAH         0x97
#define  GDATAL         0x98
#define  GDATAH         0x99
#define  BDATAL         0x9A
#define  BDATAH         0x9B


#define CDATA 0x00
#define RDATA 0x01
#define GDATA 0x02
#define BDATA 0x03

// Gesture Registers

/**The Gesture Proximity Enter Threshold Register value is compared with Proximity value, PDATA, to determine if the gesture state machine is entered. The proximity persistence filter, PPERS, is not used to determine gesture state machine entry.*/
#define  GPENTH         0xA0
/**The Gesture Proximity Exit Threshold Register value compares all non-masked gesture detection photodiodes (UDLR). Gesture state machine exit is also governed by the value in the Gesture Exit Persistence register, GEPERS.*/
#define  GEXTH          0xA1
/**The Gesture Configuration One Register contains settings that govern gesture detector masking, FIFO interrupt generation and gesture exit persistence filter.*/
#define  GCONF1         0xA2
/**The Gesture Configuration Two register contains settings that govern wait time, LDR drive current strength and Gesture gain control. The GWTIME controls the amount of time in a low power mode between gesture detection cycles. GPDRIVE sets the LDR drive current strength governing LED intensity. GGAIN sets the analog gain associated with the photodiode
output.*/
#define  GCONF2         0xA3
/**The GOFFSET_U is an 8-bit value used to scale an internal offset correction factor to compensate for crosstalk in the application. This value is encoded in sign/magnitude format.*/
#define  GOFFSET_U      0xA4
/**The GOFFSET_D is an 8-bit value used to scale an internal offset correction factor to compensate for crosstalk in the application. This value is encoded in sign/magnitude format.*/
#define  GOFFSET_D      0xA5
/**The GOFFSET_L is an 8-bit value used to scale an internal offset correction factor to compensate for crosstalk in the application. This value is encoded in sign/magnitude format.*/
#define  GOFFSET_L      0xA7
/**The GOFFSET_R is an 8-bit value used to scale an internal offset correction factor to compensate for crosstalk in the application. This value is encoded in sign/magnitude format.*/
#define  GOFFSET_R      0xA9
/**The Gesture Pulse Count Register sets Pulse Width Modified current during a Gesture Pulse. The Gesture pulse count register bits set the number of pulses to be output on the LDR pin. The Gesture Length register bits set the amount of time the LDR pin is sinking current during a gesture pulse.*/
#define  GPULSE         0xA6
/**The Gesture Configuration Three Register contains settings that govern which gesture photodiode pair: UP-DOWN and/or RIGHT-LEFT will be enabled (have valid data in FIFO) while the gesture state machine is collecting directional data.
Normal mode enables all four gesture photodiodes and places data into FIFO as expected. Disabling a photodiode pair, essentially allows the enabled pair to collect data twice as fast. Data stored in the FIFO for a disabled pair is not valid.
This feature is useful to improve reliability and accuracy of gesture detection when only one-dimensional gestures are expected.*/
#define  GCONF3         0xAA
/**The Gesture Configuration Four Register contains settings that govern Gesture interrupts and interrupt clearing/reset
as well as operation mode control and status.*/
#define  GCONF4         0xAB
/**The GFLVL Register indicates the number of datasets that are currently available in the FIFO for read. Reading a complete FIFO dataset (from address 0xFC to 0xFF) constitutes the reduction of the GPENTH register by one.*/
#define  GFLVL          0xAE
/**The GSTATUS Register indicates the operational condition of the gesture state machine.*/
#define  GSTATUS        0xAF

/**Interrupts are cleared by “address accessing” the appropriate register. This is special I2C transaction consisting of only two bytes: chip address with R/W = 0, followed by a register address.*/
#define  IFORCE         0xE4
#define  PICLEAR        0xE5
#define  CICLEAR        0xE6
#define  AICLEAR        0xE7

/**In Gesture mode, the RAM area is repurposed as a 32 x 4 byte FIFO. Data is stored in four byte blocks. Each block, called a dataset, contains one integration cycle of UP, DOWN, LEFT, & RIGHT gesture data. Thirty-two separate datasets are stored within the FIFO before wrap-around overflow. If the FIFO overflows (i.e. 33 datasets before host/system can empty FIFO) new datasets will not replace existing datasets; instead an overflow flag will be set and new data will be lost.
Host/Systems acquire gesture data by reading addresses: 0xFC, 0xFD, 0xFE, & 0xFF, which directly correspond to UP, DOWN, LEFT, & RIGHT data points. Data can be read a single byte at a time (four consecutive I2C transactions) or by using a page read.
The internal FIFO read pointer and the FIFO Level register, GFLVL, values are updated when address 0xFF is accessed (single byte transactions) or when every fourth byte, corresponding to address 0xFF, is accessed in in page mode. If the FIFO continues to be accessed after GFLVL register is zero, dataset will be read as zero values.
The recommended procedure for reading data stored in the FIFO begins when a gesture interrupt is generated (GFLVL >
GFIFOTH). Next, the host reads the FIFO Level register, GFLVL, to determine the amount of valid data in the FIFO.
Finally, the host begins to read address 0xFC (page read), and continues to read (clock-out data) until the FIFO is empty (Number of bytes is 4X GFLVL). For example, if GFLVL = 2, then the host should initiate a read at address 0xFC, and sequentially read all eight bytes. As the four-byte blocks are read, GFLVL register is decremented and the internal FIFO
pointers are updated.*/
#define  GFIFO_U        0xFC
/**Gesture FIFO DOWN value.*/
#define  GFIFO_D        0xFD
/**Gesture FIFO LEFT value.*/
#define  GFIFO_L        0xFE
/*+Gesture FIFO RIGHT value.*/
#define  GFIFO_R        0xFF

/* Bit fields Enable register */
#define PON                       0b00000001
#define AEN                       0b00000010
#define PEN                       0b00000100
#define WEN                       0b00001000
#define AIEN                      0b00010000
#define PIEN                      0b00100000
#define GEN                       0b01000000
#define ALL                       0b01111111
#define GVALID                    0b00000001

/* On/Off definitions */
#define APDS9960_OFF                       0

/* Default values */
#define DEFAULT_ATIME           219     // 103ms
#define DEFAULT_WTIME           246     // 27ms
#define DEFAULT_PROX_PPULSE     0x87    // 16us, 8 pulses
#define DEFAULT_GESTURE_PPULSE  0x89    // 16us, 10 pulses
#define DEFAULT_POFFSET_UR      0       // 0 offset
#define DEFAULT_POFFSET_DL      0       // 0 offset      
#define DEFAULT_CONFIG1         0x40    // No 12x wait (WTIME) factor
#define DEFAULT_LDRIVE          LED_DRIVE_100MA
#define DEFAULT_PGAIN           PGAIN_4X
#define DEFAULT_AGAIN           AGAIN_4X
#define DEFAULT_PILT            0       // Low proximity threshold
#define DEFAULT_PIHT            50      // High proximity threshold
#define DEFAULT_AILT            0xFFFF  // Force interrupt for calibration
#define DEFAULT_AIHT            0
#define DEFAULT_PERS            0x11    // 2 consecutive prox or ALS for int.
#define DEFAULT_CONFIG2         0x01    // No saturation interrupts or LED boost  
#define DEFAULT_CONFIG3         0       // Enable all photodiodes, no SAI
#define DEFAULT_GPENTH          40      // Threshold for entering gesture mode
#define DEFAULT_GEXTH           30      // Threshold for exiting gesture mode    
#define DEFAULT_GCONF1          0x40    // 4 gesture events for int., 1 for exit
#define DEFAULT_GGAIN           GGAIN_4X
#define DEFAULT_GLDRIVE         LED_DRIVE_100MA
#define DEFAULT_GWTIME          GWTIME_2_8MS
#define DEFAULT_GOFFSET         0       // No offset scaling for gesture mode
#define DEFAULT_GPULSE          0xC9    // 32us, 10 pulses
#define DEFAULT_GCONF3          0       // All photodiodes active during gesture
#define DEFAULT_GIEN            0       // Disable gesture interrupts

